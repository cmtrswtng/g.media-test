# План выполнения задания: Микросервис для управления задачами

## Общая оценка времени: 3 дня

### День 1: Настройка окружения и базовая архитектура (8 часов)

#### Этап 1: Инициализация проекта и настройка окружения (2 часа)
- **Задачи:**
  - Создание структуры проекта
  - Настройка package.json с необходимыми зависимостями
  - Настройка TypeScript (tsconfig.json)
  - Создание docker-compose.yml для MongoDB и RabbitMQ
- **Использование LLM:** Генерация базовой конфигурации и зависимостей
- **Проверка:** Запуск docker-compose и проверка доступности сервисов

#### Этап 2: Модели данных и схемы (2 часа)
- **Задачи:**
  - Создание модели Task с полями (id, title, description, status, dueDate)
  - Создание Fastify схем для валидации
  - Настройка TypeScript типов для безопасности
- **Использование LLM:** Генерация типов и схем валидации
- **Проверка:** Компиляция TypeScript без ошибок

#### Этап 3: GraphQL схема и кодогенерация (2 часа)
- **Задачи:**
  - Создание GraphQL схемы (schema.graphql)
  - Настройка @graphql-codegen/cli (codegen.yml)
  - Генерация TypeScript типов для резолверов
- **Использование LLM:** Создание GraphQL схемы и настройка кодогенерации
- **Проверка:** Успешная генерация типов и их использование

#### Этап 4: Настройка MongoDB подключения (2 часа)
- **Задачи:**
  - Создание сервиса для подключения к MongoDB
  - Настройка коллекции для задач
  - Базовые CRUD операции
- **Использование LLM:** Генерация кода для работы с MongoDB
- **Проверка:** Успешное подключение и выполнение операций

### День 2: Реализация API и RabbitMQ (8 часов)

#### Этап 5: Сервисы бизнес-логики (2 часа)
- **Задачи:**
  - TaskService с методами create, get, update, list
  - Использование классового подхода
  - Интеграция с MongoDB
- **Использование LLM:** Генерация методов сервиса
- **Проверка:** Юнит-тесты для основных методов

#### Этап 6: REST API контроллеры (2 часа)
- **Задачи:**
  - Создание контроллера для задач
  - Реализация эндпоинтов: GET, POST, PATCH
  - Интеграция с валидацией Fastify
- **Использование LLM:** Генерация контроллеров и роутов
- **Проверка:** Тестирование через curl или Postman

#### Этап 7: GraphQL резолверы (2 часа)
- **Задачи:**
  - Создание резолверов для Query и Mutation
  - Использование сгенерированных типов
  - Интеграция с Apollo Server
- **Использование LLM:** Генерация резолверов с типизацией
- **Проверка:** Тестирование через Postman

#### Этап 8: RabbitMQ настройка (2 часа)
- **Задачи:**
  - Создание RabbitMQ сервиса
  - Настройка Direct Exchange (task.exchange)
  - Создание очереди task.actions с routing key
  - Реализация publisher и consumer
- **Использование LLM:** Генерация кода для RabbitMQ
- **Проверка:** Отправка и получение сообщений

### День 3: Безопасность, тестирование и документация (8 часов)

#### Этап 9: Безопасность и валидация (2 часа)
- **Задачи:**
  - Настройка Fastify Validation and Serialization
  - Интеграция sanitize-html для защиты от XSS
  - Ограничение длины строк (title: 100, description: 500)
- **Использование LLM:** Генерация схем валидации и санитайзинга
- **Проверка:** Тестирование с невалидными данными

#### Этап 10: Автотесты в Postman (2 часа)
- **Задачи:**
  - Создание коллекции тестов для всех эндпоинтов
  - Тесты для GraphQL и REST API
  - Тесты валидации и обработки ошибок
- **Использование LLM:** Генерация тестовых сценариев
- **Проверка:** Выполнение всех тестов в Postman

#### Этап 11: Публичный Workspace Postman (1 час)
- **Задачи:**
  - Создание публичного Workspace
  - Приглашение
  - Экспорт JSON коллекции
- **Без LLM:** Ручная настройка Postman
- **Проверка:** Доступность Workspace для приглашенного пользователя

#### Этап 12: Финальная интеграция и документация (3 часа)
- **Задачи:**
  - Создание главного файла приложения (index.ts)
  - Настройка логирования (pino)
  - Написание README.md с полным описанием
  - Финальное тестирование всей системы
- **Использование LLM:** Генерация документации и README
- **Проверка:** Полный цикл: запуск окружения, тестирование API, RabbitMQ

## Приоритизация задач

1. **Высокий приоритет (критично для работы):**
   - Настройка окружения и Docker Compose
   - Модели данных и валидация
   - Базовые API endpoints
   - RabbitMQ интеграция

2. **Средний приоритет (важно для качества):**
   - GraphQL кодогенерация
   - Безопасность и санитайзинг
   - Полное покрытие тестами

3. **Низкий приоритет (дополнительно):**
   - Логирование
   - Детальная документация
   - Оптимизация производительности

## Использование LLM

### Где планируется использовать LLM:
- **Генерация кода:** Базовые CRUD операции, схемы валидации
- **Настройка конфигураций:** TypeScript, GraphQL Codegen, Docker Compose
- **Создание тестов:** Postman коллекции и тестовые сценарии
- **Документация:** README, комментарии к коду

### Стратегия проверки LLM кода:
1. **Компиляция TypeScript:** Все сгенерированные файлы должны проходить проверку типов
2. **Тестирование:** Каждый компонент тестируется отдельно
3. **Интеграционные тесты:** Проверка работы всей системы
4. **Код-ревью:** Ручная проверка критических частей (безопасность, бизнес-логика)

## Возможные риски и митигация

1. **Сложность интеграции RabbitMQ:** Выделено дополнительное время на отладку
2. **Проблемы с кодогенерацией GraphQL:** Подготовлен план Б с ручной типизацией
3. **Проблемы с валидацией:** Пошаговое тестирование каждой схемы
4. **Недостаток времени:** Приоритизация критических функций

## Результат

По завершении будет получен:
- Полнофункциональный микросервис с GraphQL и REST API
- Интеграция с RabbitMQ для асинхронной обработки
- Безопасная валидация и санитайзинг
- Полное покрытие автотестами
- Подробная документация и инструкции по развертыванию 